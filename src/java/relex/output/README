
There are several distinct, code-wise unrelated,
but conceptually similar systems in this directory.
All of these are focused on providing printed output 
of the RelEx graph, or the concept frames.

There are other (older) output routines in other 
directories, including printZHeads and LinakbleView.
These older output routines should be migrated here, 
or possibly deprecated.

This directory contains:

SimpleView.java:
	Provides a very simple, simplistic printing of
	the RelEx relationship graph.

RawView.java:
	Provides an indented, structurally correct graph-style
	visualization of the RelEx graph.

ParseView.java:
PhraseView.java:
RelationView.java:
	These three files, together as a group, implement
	the so-called "Cerego-style" output. There are two
	variants "plain-text" and XML. The XML format is 
	quite complex and daunting. Only ParseView is public;
	the other two are helper classes.

OpenCogXML.java:
RelXML.java:
FrameXML.java:
	Generates OpenCog XML. Only the OpenCog class is 
	public; the other two are helpers. RelXML generates
	output that corresponds to the basic RelEx feature 
	graph, while FrameXML generates output for the 
	frame relations.
	

========================================================
       Design Notes for a generic parse output format

The goal of the generic parse output format is to allow the results of
parsing a text to be stored in a relatively compact, simple format that
is easily read by various systems.  Parsing is a relatively CPU-intensive
computational task, and so having easily accessible, pre-parsed texts
offers a reasonable jumping-off point for more sophisticated search, 
reasoning and general AI systems.

The output format should meet these design requirements:
 * Easily machine readable
 * Logs dates and versions
 * Sentence order is important!


-- indicate data format version
-- indicate parse date
-- indicate parser version
-- indicate URI's of source text
-- store all unary and binary relations
-- store contituent tree.
-- store parse ranking meta-info

-- ideally, use triples (a la RDF)
-- Use s-expressions, or possibly JSON

-- Don't forget: unique word-instance ID's.
